// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

interface Message {
  message_id: string;
  timestamp: string;
  content: string;
  platform_name: string;
  platform_user_id: string;
  platform_message_id: string;
  platform_message_url: string;
}

interface RequestData {
  table_name: string;
  job_id: string;
  topic: string;
  industry: string;
  subindustry: string;
  similarity_search_score_threshold: number;
  filter_by?: string[];
  messages: Message[];
}

interface ProcessingResult {
  inserted: Array<{ message_id: string; content: string }>;
  dropped: number;
}

export default {
  async fetch(request: Request, env: any, ctx: ExecutionContext): Promise {
    if (request.method !== "POST") {
      return new Response(
        JSON.stringify({
          status: "error",
          message: "Method not allowed. Use POST.",
        }),
        { status: 405, headers: { "Content-Type": "application/json" } },
      );
    }

    const authToken = request.headers.get("Authorization");
    if (
      !authToken ||
      !authToken.startsWith("Bearer ") ||
      authToken.substring(7) !== env.DEDUP_AUTH_TOKEN
    ) {
      return new Response(
        JSON.stringify({
          status: "error",
          message: "Unauthorized. Invalid token.",
        }),
        { status: 401, headers: { "Content-Type": "application/json" } },
      );
    }

    let client = null;
    try {
      const data: RequestData = await request.json();
      console.log(
        `INFO: Processing job=${data.job_id}, received ${data.messages.length} messages`,
      );

      if (!isValidRequest(data)) {
        return new Response(
          JSON.stringify({
            status: "error",
            message: "Invalid request format",
          }),
          { status: 400, headers: { "Content-Type": "application/json" } },
        );
      }

      const filterBy = data.filter_by || ["topic", "subindustry"];
      const uniqueMessages = removeDuplicates(data.messages);
      const exactDuplicatesCount = data.messages.length - uniqueMessages.length;
      console.log(`INFO: Removed ${exactDuplicatesCount} exact duplicates`);

      client = new Client({
        connectionString: env.HYPERDRIVE.connectionString,
      });
      await client.connect();
      console.log("INFO: Connected to database");

      const results = await processMessages(
        client,
        env,
        data,
        uniqueMessages,
        filterBy,
      );

      const stats = {
        received: data.messages.length,
        inserted: results.inserted.length,
        dropped: exactDuplicatesCount + results.dropped,
        insertion_rate:
          data.messages.length > 0
            ? results.inserted.length / data.messages.length
            : 0,
      };

      return new Response(
        JSON.stringify({
          status: "success",
          data: {
            table_name: data.table_name,
            job_id: data.job_id,
            topic: data.topic,
            industry: data.industry,
            subindustry: data.subindustry,
            similarity_search_score_threshold:
              data.similarity_search_score_threshold,
            filter_by: filterBy,
            stats,
            non_duplicate_messages: results.inserted,
          },
          message: "Batch processing completed successfully",
        }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      );
    } catch (error) {
      console.error(`ERROR: Request processing failed: ${error.message}`);
      return new Response(
        JSON.stringify({
          status: "error",
          message: "Internal server error",
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    } finally {
      if (client) {
        try {
          await client.end();
          console.log("INFO: Database connection closed");
        } catch (e) {
          console.error(
            `ERROR: Failed to close database connection: ${e.message}`,
          );
        }
      }
    }
  },
};

function isValidRequest(data: RequestData): boolean {
  if (
    !data.table_name ||
    !data.job_id ||
    !data.topic ||
    !data.industry ||
    !data.messages ||
    !Array.isArray(data.messages) ||
    typeof data.similarity_search_score_threshold !== "number" ||
    data.similarity_search_score_threshold < 0 ||
    data.similarity_search_score_threshold > 1 ||
    !/^[a-zA-Z0-9_]+$/.test(data.table_name)
  ) {
    return false;
  }

  if (data.filter_by) {
    const validFields = ["job_id", "topic", "industry", "subindustry"];
    if (!data.filter_by.every((f) => validFields.includes(f))) return false;
  }

  return true;
}

function removeDuplicates(messages: Message[]): Message[] {
  const seen = new Set();
  return messages.filter((msg) => {
    if (seen.has(msg.content)) return false;
    seen.add(msg.content);
    return true;
  });
}

async function processMessages(
  client: any,
  env: any,
  data: RequestData,
  messages: Message[],
  filterBy: string[],
): Promise {
  const inserted: Array<{ message_id: string; content: string }> = [];
  let dropped = 0;
  const batchSize = 100;

  for (let i = 0; i < messages.length; i += batchSize) {
    const batch = messages.slice(i, i + batchSize);
    try {
      const embeddings = await generateEmbeddings(
        batch.map((msg) => msg.content),
        env,
      );
      console.log(
        `INFO: Generated embeddings for batch of ${batch.length} messages`,
      );

      for (let j = 0; j < batch.length; j++) {
        try {
          const message = batch[j];
          const embedding = embeddings[j];
          const formattedEmbedding = `[${embedding.join(",")}]`;

          const similarityResult = await checkSimilarity(
            client,
            data.table_name,
            formattedEmbedding,
            data.job_id,
            data.topic,
            data.industry,
            data.subindustry,
            filterBy,
          );

          if (
            !similarityResult ||
            similarityResult.similarity_score <
              data.similarity_search_score_threshold
          ) {
            const similarityScore = similarityResult?.similarity_score || 0;
            await insertMessage(
              client,
              data.table_name,
              data.job_id,
              message,
              data.topic,
              data.industry,
              data.subindustry,
              formattedEmbedding,
              similarityScore,
            );
            inserted.push({
              message_id: message.message_id,
              content: message.content,
            });
            console.log(
              `INFO: Inserted message=${message.message_id}, similarity=${similarityScore}`,
            );
          } else {
            dropped++;
            console.log(
              `INFO: Dropped message=${message.message_id}, similarity=${similarityResult.similarity_score}`,
            );
          }
        } catch (e) {
          console.error(`ERROR: Processing message failed: ${e.message}`);
          dropped++;
        }
      }
    } catch (e) {
      console.error(`ERROR: Batch processing failed: ${e.message}`);
      dropped += batch.length;
    }
  }

  return { inserted, dropped };
}

async function generateEmbeddings(
  texts: string[],
  env: any,
): Promise<number[][]> {
  try {
    const modelName = "bge-m3";
    const response = await env.AI.run(modelName, { text: texts });
    return response.data;
  } catch (e) {
    console.error(`ERROR: Embedding generation failed: ${e.message}`);
    throw e;
  }
}

async function checkSimilarity(
  client: any,
  tableName: string,
  embedding: string,
  jobId: string,
  topic: string,
  industry: string,
  subindustry: string,
  filterBy: string[],
): Promise<{ similarity_score: number; content: string } | null> {
  try {
    const conditions = [];
    const params = [];
    let idx = 1;

    if (filterBy.includes("job_id")) {
      conditions.push(`job_id = $${idx++}`);
      params.push(jobId);
    }
    if (filterBy.includes("topic")) {
      conditions.push(`topic = $${idx++}`);
      params.push(topic);
    }
    if (filterBy.includes("industry")) {
      conditions.push(`industry = $${idx++}`);
      params.push(industry);
    }
    if (filterBy.includes("subindustry") && subindustry) {
      conditions.push(`subindustry = $${idx++}`);
      params.push(subindustry);
    }

    const whereClause =
      conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";
    params.push(embedding);

    const query = `
      SELECT 1 - (embedding <=> $${idx}::vector) as similarity_score, content
      FROM ${tableName}
      ${whereClause}
      ORDER BY similarity_score DESC
      LIMIT 1;
    `;

    const result = await client.query(query, params);
    return result.rows.length > 0
      ? {
          similarity_score: result.rows[0].similarity_score,
          content: result.rows[0].content,
        }
      : null;
  } catch (e) {
    console.error(`ERROR: Similarity check failed: ${e.message}`);
    throw e;
  }
}

async function insertMessage(
  client: any,
  tableName: string,
  jobId: string,
  message: Message,
  topic: string,
  industry: string,
  subindustry: string,
  embedding: string,
  similarityScore: number,
): Promise {
  try {
    const query = `
      INSERT INTO ${tableName} (
        job_id, message_id, timestamp, topic, industry, subindustry, 
        content, embedding, similarity_search_score, platform_name, 
        platform_user_id, platform_message_id, platform_message_url
      ) 
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
    `;

    await client.query(query, [
      jobId,
      message.message_id,
      message.timestamp,
      topic,
      industry,
      subindustry || null,
      message.content,
      embedding,
      similarityScore,
      message.platform_name,
      message.platform_user_id,
      message.platform_message_id,
      message.platform_message_url,
    ]);
  } catch (e) {
    console.error(
      `ERROR: Message insertion failed for ${message.message_id}: ${e.message}`,
    );
    throw e;
  }
}
