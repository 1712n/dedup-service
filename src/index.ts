// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

export interface Env {
  AI: {
    run: (
      modelName: string,
      data: { text: string[] },
    ) => Promise<{ data: number[][] }>;
  };
  HYPERDRIVE: {
    connectionString: string;
  };
  DEDUP_AUTH_TOKEN: string;
}

interface Message {
  message_id: string;
  timestamp?: string;
  content: string;
  platform_name?: string;
  platform_user_id?: string;
  platform_message_id?: string;
  platform_message_url?: string;
}

interface RequestData {
  table_name: string;
  job_id: string;
  topic: string;
  industry: string;
  subindustry: string;
  similarity_search_score_threshold: number;
  filter_by?: string[];
  messages: Message[];
}

interface ResponseData {
  table_name: string;
  job_id: string;
  topic: string;
  industry: string;
  subindustry: string;
  similarity_search_score_threshold: number;
  filter_by: string[];
  stats: {
    received: number;
    inserted: number;
    dropped: number;
    insertion_rate: number;
  };
  non_duplicate_messages: {
    message_id: string;
    content: string;
  }[];
}

const MODEL_NAME = "@cf/baai/bge-m3";
const MAX_BATCH_SIZE = 100;

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise {
    try {
      if (request.method !== "POST") {
        return new Response(
          JSON.stringify({
            status: "error",
            message: "Method not allowed",
            error: "Only POST requests are supported",
          }),
          {
            status: 405,
            headers: { "Content-Type": "application/json" },
          },
        );
      }

      const authHeader = request.headers.get("Authorization");
      if (!authHeader || authHeader !== `Bearer ${env.DEDUP_AUTH_TOKEN}`) {
        return new Response(
          JSON.stringify({
            status: "error",
            message: "Unauthorized",
            error: "Invalid or missing authentication token",
          }),
          {
            status: 401,
            headers: { "Content-Type": "application/json" },
          },
        );
      }

      const requestData: RequestData = await request.json();
      if (!validateRequestData(requestData)) {
        return new Response(
          JSON.stringify({
            status: "error",
            message: "Invalid request data",
            error: "Missing required fields or invalid format",
          }),
          {
            status: 400,
            headers: { "Content-Type": "application/json" },
          },
        );
      }

      const result = await processMessages(requestData, env);
      return new Response(JSON.stringify(result), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    } catch (error) {
      console.error("ERROR: Processing request failed:", error);
      return new Response(
        JSON.stringify({
          status: "error",
          message: "Internal server error",
          error: error instanceof Error ? error.message : "Unknown error",
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" },
        },
      );
    }
  },
};

function validateRequestData(data: any): boolean {
  if (!data) return false;

  if (
    !data.table_name ||
    !data.job_id ||
    !data.topic ||
    !data.industry ||
    typeof data.similarity_search_score_threshold !== "number" ||
    !Array.isArray(data.messages)
  ) {
    return false;
  }

  if (
    data.similarity_search_score_threshold < 0 ||
    data.similarity_search_score_threshold > 1
  ) {
    return false;
  }

  if (data.messages.length === 0) {
    return false;
  }

  for (const message of data.messages) {
    if (!message.message_id || !message.content) {
      return false;
    }
  }

  return true;
}

async function processMessages(requestData: RequestData, env: Env): Promise {
  const startTime = Date.now();
  console.info(
    `INFO: Starting batch processing for job_id: ${requestData.job_id}, received ${requestData.messages.length} messages`,
  );

  const filterBy = requestData.filter_by || ["topic", "subindustry"];

  // Remove exact duplicates first
  const uniqueContentMap = new Map<string, Message>();
  for (const message of requestData.messages) {
    uniqueContentMap.set(message.content, message);
  }

  const uniqueMessages = Array.from(uniqueContentMap.values());
  const exactDuplicatesCount =
    requestData.messages.length - uniqueMessages.length;
  console.info(
    `INFO: Removed ${exactDuplicatesCount} exact duplicate messages`,
  );

  // Connect to database
  const client = new Client({
    connectionString: env.HYPERDRIVE.connectionString,
  });
  try {
    await client.connect();
    console.info(`INFO: Database connection established`);

    const nonDuplicateMessages: { message_id: string; content: string }[] = [];
    let insertedCount = 0;

    // Process messages in batches for embeddings
    const batchCount = Math.ceil(uniqueMessages.length / MAX_BATCH_SIZE);
    console.info(
      `INFO: Processing ${uniqueMessages.length} messages in ${batchCount} batches`,
    );

    for (let batchIndex = 0; batchIndex < batchCount; batchIndex++) {
      const batchStart = batchIndex * MAX_BATCH_SIZE;
      const batchEnd = Math.min(
        batchStart + MAX_BATCH_SIZE,
        uniqueMessages.length,
      );
      const messageBatch = uniqueMessages.slice(batchStart, batchEnd);

      try {
        // Get embeddings for the batch
        const batchTexts = messageBatch.map((message) => message.content);
        const embeddingResponse = await env.AI.run(MODEL_NAME, {
          text: batchTexts,
        });
        const embeddings = embeddingResponse.data;

        // Process each message
        for (let i = 0; i < messageBatch.length; i++) {
          const message = messageBatch[i];
          const embedding = embeddings[i];
          const formattedEmbedding = `[${embedding.join(",")}]`;

          try {
            // Build filter conditions and parameters
            const filterParams = [];
            const filterConditions = filterBy
              .map((field) => {
                if (field === "job_id") {
                  filterParams.push(requestData.job_id);
                  return `job_id = $${filterParams.length}`;
                }
                if (field === "topic") {
                  filterParams.push(requestData.topic);
                  return `topic = $${filterParams.length}`;
                }
                if (field === "industry") {
                  filterParams.push(requestData.industry);
                  return `industry = $${filterParams.length}`;
                }
                if (field === "subindustry") {
                  filterParams.push(requestData.subindustry);
                  return `subindustry = $${filterParams.length}`;
                }
                return null;
              })
              .filter(Boolean)
              .join(" AND ");

            // Add embedding parameter
            filterParams.push(formattedEmbedding);

            // Check for similar messages
            const similarityQuery = `
              SELECT content, embedding <=> $${filterParams.length}::vector AS distance
              FROM ${requestData.table_name}
              ${filterConditions ? `WHERE ${filterConditions}` : ""}
              ORDER BY distance ASC
              LIMIT 1;
            `;

            const similarityResult = await client.query(
              similarityQuery,
              filterParams,
            );

            let similarityScore = 0;
            if (similarityResult.rows.length > 0) {
              const distance = similarityResult.rows[0].distance;
              // Convert distance to similarity score (higher means more similar)
              similarityScore = 1 / (1 + distance);
            }

            // Check if message exceeds similarity threshold
            if (
              similarityScore > requestData.similarity_search_score_threshold
            ) {
              console.info(
                `INFO: Dropped near-duplicate message ${message.message_id}, similarity: ${similarityScore}`,
              );
            } else {
              // Insert non-duplicate message
              const insertQuery = `
                INSERT INTO ${requestData.table_name} (
                  job_id, message_id, timestamp, topic, industry, subindustry, 
                  content, embedding, similarity_search_score,
                  platform_name, platform_user_id, platform_message_id, platform_message_url
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                RETURNING id;
              `;

              const insertParams = [
                requestData.job_id,
                message.message_id,
                message.timestamp || new Date().toISOString(),
                requestData.topic,
                requestData.industry,
                requestData.subindustry || null,
                message.content,
                formattedEmbedding,
                similarityScore,
                message.platform_name || null,
                message.platform_user_id || null,
                message.platform_message_id || null,
                message.platform_message_url || null,
              ];

              const insertResult = await client.query(
                insertQuery,
                insertParams,
              );

              if (insertResult.rows.length > 0) {
                insertedCount++;
                nonDuplicateMessages.push({
                  message_id: message.message_id,
                  content: message.content,
                });
                console.info(
                  `INFO: Inserted message ${message.message_id}, similarity: ${similarityScore}`,
                );
              }
            }
          } catch (error) {
            console.error(
              `ERROR: Failed processing message ${message.message_id}:`,
              error,
            );
          }
        }
      } catch (error) {
        console.error(
          `ERROR: Failed processing batch ${batchIndex + 1}:`,
          error,
        );
      }
    }

    const totalReceived = requestData.messages.length;
    const totalDropped = totalReceived - insertedCount;
    const insertionRate = totalReceived > 0 ? insertedCount / totalReceived : 0;

    const responseData: ResponseData = {
      table_name: requestData.table_name,
      job_id: requestData.job_id,
      topic: requestData.topic,
      industry: requestData.industry,
      subindustry: requestData.subindustry,
      similarity_search_score_threshold:
        requestData.similarity_search_score_threshold,
      filter_by: filterBy,
      stats: {
        received: totalReceived,
        inserted: insertedCount,
        dropped: totalDropped,
        insertion_rate: insertionRate,
      },
      non_duplicate_messages: nonDuplicateMessages,
    };

    const processingTime = (Date.now() - startTime) / 1000;
    console.info(
      `INFO: Completed processing for job_id: ${requestData.job_id} in ${processingTime}s. Inserted: ${insertedCount}/${totalReceived}`,
    );

    return {
      status: "success",
      data: responseData,
      message: "Batch processing completed successfully",
    };
  } catch (error) {
    console.error(`ERROR: Failed to process batch:`, error);
    throw error;
  } finally {
    try {
      await client.end();
      console.info(`INFO: Database connection closed`);
    } catch (err) {
      console.error(`ERROR: Failed to close database connection:`, err);
    }
  }
}
