// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

interface Message {
  message_id: string;
  timestamp: string;
  content: string;
  platform_name: string;
  platform_user_id: string;
  platform_message_id: string;
  platform_message_url: string;
}

interface BatchRequest {
  table_name: string;
  job_id: string;
  topic: string;
  industry: string;
  subindustry?: string;
  similarity_search_score_threshold: number;
  filter_by?: string[];
  messages: Message[];
}

interface ProcessedMessage extends Message {
  similarity_search_score: number;
}

interface BatchResponse {
  status: string;
  data?: {
    table_name: string;
    job_id: string;
    topic: string;
    industry: string;
    subindustry?: string;
    similarity_search_score_threshold: number;
    filter_by: string[];
    stats: {
      received: number;
      inserted: number;
      dropped: number;
      insertion_rate: number;
    };
    non_duplicate_messages: Array<{
      message_id: string;
      content: string;
      similarity_search_score: number;
    }>;
  };
  message: string;
}

export default {
  async fetch(request: Request, env: Env): Promise {
    if (request.method !== "POST") {
      return new Response(
        JSON.stringify({ status: "error", message: "Method not allowed" }),
        { status: 405, headers: { "Content-Type": "application/json" } },
      );
    }
    const authHeader = request.headers.get("Authorization");
    if (!authHeader || authHeader !== `Bearer ${env.DEDUP_AUTH_TOKEN}`) {
      console.error("ERROR: Unauthorized access attempt");
      return new Response(
        JSON.stringify({ status: "error", message: "Unauthorized" }),
        { status: 401, headers: { "Content-Type": "application/json" } },
      );
    }
    let batchRequest: BatchRequest;
    try {
      batchRequest = await request.json();
      console.info(
        `INFO: Received batch - table: ${batchRequest.table_name}, job_id: ${batchRequest.job_id}, messages: ${batchRequest.messages.length}`,
      );
    } catch (error) {
      console.error("ERROR: Invalid JSON payload", error);
      return new Response(
        JSON.stringify({ status: "error", message: "Invalid JSON payload" }),
        { status: 400, headers: { "Content-Type": "application/json" } },
      );
    }
    const filterBy = batchRequest.filter_by || ["topic", "industry"];
    const client = new Client({
      connectionString: env.HYPERDRIVE.connectionString,
    });
    try {
      await client.connect();
      console.info("INFO: Database connection established");
      const uniqueMessages = new Map<string, Message>();
      for (const msg of batchRequest.messages) {
        uniqueMessages.set(msg.content, msg);
      }
      const deduplicatedMessages = Array.from(uniqueMessages.values());
      const exactDuplicatesRemoved =
        batchRequest.messages.length - deduplicatedMessages.length;
      console.info(`INFO: Removed ${exactDuplicatesRemoved} exact duplicates`);
      const processedMessages: ProcessedMessage[] = [];
      for (let i = 0; i < deduplicatedMessages.length; i += 100) {
        const batch = deduplicatedMessages.slice(i, i + 100);
        const texts = batch.map((msg) => msg.content);
        try {
          const embeddingResponse = await env.AI.run("@cf/baai/bge-m3", {
            text: texts,
          });
          console.info(
            `INFO: Generated embeddings for batch ${Math.floor(i / 100) + 1}`,
          );
          for (let j = 0; j < batch.length; j++) {
            const msg = batch[j];
            const embedding = embeddingResponse.data[j];
            const formattedEmbedding = `[${embedding.join(",")}]`;
            let similarityScore = 0;
            try {
              const whereConditions = filterBy
                .map((field, idx) => {
                  switch (field) {
                    case "topic":
                      return `topic = $${idx + 2}`;
                    case "industry":
                      return `industry = $${idx + 2}`;
                    case "subindustry":
                      return `subindustry = $${idx + 2}`;
                    case "job_id":
                      return `job_id = $${idx + 2}`;
                    default:
                      return null;
                  }
                })
                .filter(Boolean)
                .join(" AND ");
              const queryParams = [formattedEmbedding];
              filterBy.forEach((field) => {
                switch (field) {
                  case "topic":
                    queryParams.push(batchRequest.topic);
                    break;
                  case "industry":
                    queryParams.push(batchRequest.industry);
                    break;
                  case "subindustry":
                    queryParams.push(batchRequest.subindustry || "");
                    break;
                  case "job_id":
                    queryParams.push(batchRequest.job_id);
                    break;
                }
              });
              const searchQuery = `SELECT 1 - (embedding <=> $1::vector) as similarity FROM ${batchRequest.table_name} WHERE ${whereConditions} ORDER BY embedding <=> $1::vector LIMIT 1`;
              const searchResult = await client.query(searchQuery, queryParams);
              if (searchResult.rows.length > 0) {
                similarityScore = searchResult.rows[0].similarity;
              }
              console.info(
                `INFO: Message ${msg.message_id} similarity score: ${similarityScore}`,
              );
            } catch (error) {
              console.error(
                `ERROR: Similarity search failed for message ${msg.message_id}`,
                error,
              );
            }
            if (
              similarityScore < batchRequest.similarity_search_score_threshold
            ) {
              try {
                const insertQuery = `INSERT INTO ${batchRequest.table_name} (job_id, message_id, timestamp, topic, industry, subindustry, content, embedding, similarity_search_score, platform_name, platform_user_id, platform_message_id, platform_message_url) VALUES ($1, $2, $3, $4, $5, $6, $7, $8::vector, $9, $10, $11, $12, $13)`;
                await client.query(insertQuery, [
                  batchRequest.job_id,
                  msg.message_id,
                  msg.timestamp,
                  batchRequest.topic,
                  batchRequest.industry,
                  batchRequest.subindustry || null,
                  msg.content,
                  formattedEmbedding,
                  similarityScore,
                  msg.platform_name,
                  msg.platform_user_id,
                  msg.platform_message_id,
                  msg.platform_message_url,
                ]);
                processedMessages.push({
                  ...msg,
                  similarity_search_score: similarityScore,
                });
                console.info(`INFO: Inserted message ${msg.message_id}`);
              } catch (error) {
                console.error(
                  `ERROR: Failed to insert message ${msg.message_id}`,
                  error,
                );
              }
            } else {
              console.info(
                `INFO: Dropped message ${msg.message_id} - similarity ${similarityScore} exceeds threshold ${batchRequest.similarity_search_score_threshold}`,
              );
            }
          }
        } catch (error) {
          console.error(
            `ERROR: Embedding generation failed for batch ${Math.floor(i / 100) + 1}`,
            error,
          );
        }
      }
      const stats = {
        received: batchRequest.messages.length,
        inserted: processedMessages.length,
        dropped: batchRequest.messages.length - processedMessages.length,
        insertion_rate: processedMessages.length / batchRequest.messages.length,
      };
      const response: BatchResponse = {
        status: "success",
        data: {
          table_name: batchRequest.table_name,
          job_id: batchRequest.job_id,
          topic: batchRequest.topic,
          industry: batchRequest.industry,
          subindustry: batchRequest.subindustry,
          similarity_search_score_threshold:
            batchRequest.similarity_search_score_threshold,
          filter_by: filterBy,
          stats,
          non_duplicate_messages: processedMessages.map((msg) => ({
            message_id: msg.message_id,
            content: msg.content,
            similarity_search_score: msg.similarity_search_score,
          })),
        },
        message: "Batch processing completed successfully",
      };
      console.info(
        `INFO: Batch processing complete - inserted: ${stats.inserted}, dropped: ${stats.dropped}`,
      );
      return new Response(JSON.stringify(response), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    } catch (error) {
      console.error("ERROR: Batch processing failed", error);
      return new Response(
        JSON.stringify({ status: "error", message: "Internal server error" }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    } finally {
      try {
        await client.end();
        console.info("INFO: Database connection closed");
      } catch (error) {
        console.error("ERROR: Failed to close database connection", error);
      }
    }
  },
};
